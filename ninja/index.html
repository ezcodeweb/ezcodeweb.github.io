<!DOCTYPE html>
<html>
    <!-- header setup -->
    <head>
        <!-- standard setup -->
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <!-- import some nice google fonts -->
        <link href='https://fonts.googleapis.com/css2?family=Josefin+Sans' rel='stylesheet'>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Sigmar+One&display=swap" rel="stylesheet">
        <!-- name of the game -->
        <title>Spin-off of "Vigil of the Ninja (Official Release)"</title>
        <!-- some quick stylin' -->
        <style>
            body {
              background: black;
              overflow: hidden;
              display: flex;
              height: 100vh;
              align-items: center;
              justify-content: center;
              margin: 0;
              padding: 0;
            }
            /* canvas takes up the whole screen */
            canvas {
                width: min(100vw, 100vh);
                height: auto !important;
                z-index: 0;
            }
            /* ignore the ridiculous println stylin' */
            .print {
                display: none;
                position: fixed;
                top: 0;
                background: rgb(0, 0, 0, 0.5);
                z-index: 1;
                width: 100vw;
                height: 20vh;
                resize: vertical;
                color: rgb(245, 245, 245, 0.5);
                overflow-x: hidden;
                overflow-y: auto;
                font-size: 3vmin;
                font-family: "Josefin Sans";
                user-select: text;
            }
            .close {
                position: absolute;
                top: 0;
                right: 0;
                margin: 1vmin;
                width: 10vmin;
                height: 5vmin;
                background: none;
                border: 1px rgb(245, 245, 245, 0.5);
                cursor: pointer;
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 4vmin;
                color: rgb(245, 245, 245, 0.5);
                z-index: 1;
                transition: 0.5s;
                font-family: 'Josefin Sans';
                user-select: none;
            }
            .close:hover {
                width: 15vmin;
                color: rgb(245, 50, 50, 0.625);
            }
            .close:active {
                color: rgb(245, 245, 245, 0.75);
            }
            .line {
                margin: 1vmin;
                z-index: 1;
            }
        </style>
    </head>
    <!-- body -->
    <body>
        <!-- canvas [where the magic happens] -->
        <canvas></canvas>
        <div class = "print">
            <button class = "close">close</button>
        </div>
        <!-- all variables at global scope -->
        <script>
            var __font_size, __font, canvas, ctx, width, height, draw, CORNER, CENTER, CLOSE, LEFT, RIGHT, UP, DOWN, SQUARE, ROUND, PROJECT, MITER, BEVEL, DEGREES, RADIANS, left, right, data, v, frameCount, frameRate, millis, debug, equal, day, month, year, hour, minute, seconds, enableContextMenu, smooth, cursor, angleMode, max, min, mag, dist, exp, norm, map, lerp, random, constrain, log, sqrt, sq, pow, abs, floor, ceil, round, sin, cos, tan, acos, asin, atan, atan2, radians, degrees, fill, stroke, background, color, noStroke, noFill, comp, rect, clear, text, rectMode, ellipseMode, createFont, textAlign, textFont, textSize, strokeCap, strokeJoin, strokeWeight, pushMatrix, popMatrix, translate, rotate, scale, beginShape, vertex, curveVertex, bezierVertex, endShape, curve, bezier, arc, ellipse, quad, triangle, point, line, textWidth, textAscent, textDescent, get, mask, image, mousePressed, mouseReleased, mouseScrolled, mouseClicked, mouseOver, mouseOut, mouseMoved, mouseIsPressed, mouseButton, mouseX, mouseY, pmouseX, pmouseY, keyPressed, keyReleased, keyTyped, key, keyIsPressed, keyCode, resetMatrix, clearLogs, println, clear, bezierPoint, bezierTangent, vec, fps
        </script>
        <!-- improved ski.js -->
        <script type = 'module'>
            //library [
            //some setup [
            const logger = document.getElementsByClassName('print')[0]
            canvas = document.getElementsByTagName('canvas')[0]
            ctx = canvas.getContext('2d')
            width = canvas.width = 600
            height = canvas.height = 600
            draw = () => {}
            //]
            //a bunch of constants [
            CORNER = new Number(0)
            CENTER = new Number(1)
            CLOSE = new Boolean(true)
            LEFT = new Number(37)
            RIGHT = new Number(39)
            UP = new Number(38)
            DOWN = new Number(40)
            SQUARE = new String('butt')
            ROUND = new String('round') 
            PROJECT = new String('square')
            MITER = new String('miter') 
            BEVEL = new String('bevel') 
            DEGREES = new String('deg') 
            RADIANS = new String('rad') 
            left = new Number(0)
            right = new Number(2)
            //]
            //general data to be stored
            data = {
                rect: 1,
                ellipse: 1,
                height: 12,
                angle: 'deg',
                date: Date.now(),
                rate: 60,
                millis: Date.now(),
                last: Date.now(),
                
            }
            //fps
            fps = 60
            //vector array
            v = []
            //animation [
            frameCount = 0
            frameRate = rate => data.rate = rate
            millis = () => data.millis
            //]
            //miscellaneous [
            debug = function(){
                console.debug(...arguments)
            }
            equal = function(){
                console.assert(...arguments)
            }
            day = () => new Date().getDate()
            month = () => new Date().getMonth()
            year = () => new Date().getYear()
            hour = () => new Date().getHours()
            minute = () => new Date().getMinutes()
            seconds = () => new Date().getSeconds()
            enableContextMenu = () => canvas.oncontextmenu = true
            cursor = name => document.body.style.cursor = name
            smooth = () => {
                ctx.imageSmoothingEnabled = true
                ctx.imageSmoothingQuality = 'high'
            }
            angleMode = mode => data.angle = mode
            clearLogs = () => logger.innerHTML = '<button class = "close">close</button>'
            println = function(){
                let msg = {...arguments}
                logger.style.display = "block"
                logger.innerHTML += `<div class = 'line'>
                    ${(msg => {
                        let string = ''
                        for(let i in msg){
                            string += msg[i] + ' '
                        }
                        return string.trim()
                    })(msg)}
                </div>`
            }
            //]
            //math [
            //complex[ish] math
            max = (n, N) => n < N ? N : n
            min = (n, N) => n < N ? n : N
            mag = (a, b) => Math.sqrt((a ** 2) + (b ** 2))
            dist = (x, y, X, Y) => mag(x - X, y - Y)
            exp = n => Math.E ** n
            norm = (val, low, high) => (val - low) / (high - low)
            map = (val, s, e, S, E) => S + (E - S) * norm(val, s, e)
            lerp = (val, targ, amt) => ((targ - val) * amt) + val
            random = (min, max) => max ? (Math.random() * (max - min)) + min : min ? (Math.random() * min) : Math.random()
            constrain = (val, low, high) => min(max(val, low), high)
            //simple math
            log = n => Math.log(n)
            sqrt = n => Math.sqrt(n)
            sq = n => n ** 2
            pow = (n, a) => n ** a
            abs = n => n < 0 ? -n : n
            floor = n => n | 0
            ceil = n => (n | 0) + 1
            round = n => n - (n | 0) < 0.5 ? (n | 0) : (n | 0) + 1
            //trig
            sin = ang => Math.sin(degrees(ang))
            cos = ang => Math.cos(degrees(ang))
            tan = ang => Math.tan(degrees(ang))
            acos = ang => Math.acos(degrees(ang))
            asin = ang => Math.asin(degrees(ang))
            atan = ang => Math.atan(degrees(ang))
            radians = ang => ang * (180 / Math.PI)
            degrees = ang => ang * (Math.PI / 180)
            atan2 = (y, x) => Math.atan2(y, x)
            bezierPoint = (a, b, c, d, t) => (1 - t) * (1 - t) * (1 - t) * a + 3 * (1 - t) * (1 - t) * t * b + 3 * (1 - t) * t * t * c + t * t * t * d
            bezierTangent = (a, b, c, d, t) => (3 * t * t * (-a + 3 * b - 3 * c + d) + 6 * t * (a - 2 * b + c) + 3 * (-a + b))
            //]
            //colorin' [
            fill = function(r, g, b, a) {
                switch(arguments.length){
                    case 1:
                        ctx.fillStyle = typeof r === 'string' ? r : `rgb(${r}, ${r}, ${r}, 255)`
                    break;
                    case 2:
                        ctx.fillStyle = `rgb(${r}, ${r}, ${r}, ${g / 255})`
                    break;
                    case 3:
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b}, 255)`
                    break;
                    case 4:
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b}, ${a / 255})`
                }
            }
            color = function (r, g, b, a) {
                switch(arguments.length){
                    case 1:
                        return `rgba(${r}, ${r}, ${r}, 255)`
                    break
                    case 2:
                        return `rgba(${r}, ${r}, ${r}, ${g / 255})`
                    break
                    case 3:
                        return `rgba(${r}, ${g}, ${b}, 255)`
                    break;
                    case 4:
                        return `rgba(${r}, ${g}, ${b}, ${a / 255})`
                    break
                }
            }
            stroke = function(r, g, b, a) {
                switch(arguments.length){
                    case 1:
                        ctx.strokeStyle =  typeof r === 'string' ? r : `rgb(${r}, ${r}, ${r}, 255)`
                    break;
                    case 2:
                        ctx.strokeStyle = `rgb(${r}, ${r}, ${r}, ${g / 255})`
                    break;
                    case 3:
                        ctx.strokeStyle = `rgb(${r}, ${g}, ${b}, 255)`
                    break;
                    case 4:
                        ctx.strokeStyle = `rgb(${r}, ${g}, ${b}, ${a / 255})`
                }
            }
            background = function(r, g, b, a) {
                let prev = [ctx.strokeStyle, ctx.fillStyle]
                switch(arguments.length){
                    case 1:
                        document.body.style.background = ctx.fillStyle = typeof r === 'string' ? r : `rgb(${r}, ${r}, ${r}, 255)`
                    break;
                    case 2:
                        document.body.style.background = ctx.fillStyle = `rgb(${r}, ${r}, ${r}, ${g / 255})`
                    break;
                    case 3:
                        document.body.style.background = ctx.fillStyle = `rgb(${r}, ${g}, ${b}, 255)`
                    break;
                    case 4:
                        document.body.style.background = ctx.fillStyle = `rgb(${r}, ${g}, ${b}, ${a / 255})`
                }
                noStroke()
                ctx.fillRect(0, 0, width, height)
                ctx.strokeStyle = prev[0]
                ctx.fillStyle = prev[1]
            }
            clear = () => {
                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight)
            }
            noStroke = () => ctx.strokeStyle = 'rgb(0, 0, 0, 0)'
            noFill = () => ctx.fillStyle = 'rgb(0, 0, 0, 0)'
            //]
            //shapes [
            comp = (x, y, w, h, draw) => data[draw] > 0 ? [x - w / 2, y - h / 2] : [x, y]
            rect = (x, y, width, height, tl, tr, br, bl) => {
                [x, y] = comp(x, y, width, height, 'rect')
                if(tl){
                    const w = width / 2, h = height / 2
                    tl = tl > w || tl > h ? Math.min(w, h) : tl
                    tr = !bl ? tl : tr
                    tr = tr > w || tr > h ? Math.min(w, h) : tr
                    br = !bl ? tl : br
                    br = br > w || br > h ? Math.min(w, h) : br
                    bl = !bl ? tl : bl
                    bl = bl > w || bl > h ? Math.min(w, h) : bl
                    if (ctx.strokeStyle === 'rgba(0, 0, 0, 0)') 
                        ctx.translate(0.5, 0.5)
                    beginShape()
                    vertex(x + tl, y)
                    vertex(x + width - tr, y)
                    curveVertex(x + width, y, x + width, y + tr)
                    vertex(x + width, y + height - br)
                    curveVertex(x + width, y + height, x + width - br, y + height)
                    vertex(x + bl, y + height)
                    curveVertex(x, y + height, x, y + height - bl)
                    vertex(x, y + tl)
                    curveVertex(x, y, x + tl, y)
                    endShape()
                    if (ctx.strokeStyle === 'rgba(0, 0, 0, 0)') 
                        ctx.translate(-0.5, -0.5)
                }
                else {
                    ctx.strokeRect(x, y, width, height)
                    ctx.fillRect(x, y, width, height)
                }
            }
            clear = () => ctx.clearRect(0, 0, canvas.width, canvas.height)
            text = (msg, x, y) => {
                msg = Object.is(typeof msg, 'string') ? msg : msg.toString()
                if(msg.match('\n')){
                    msg.split('\n').map((p, i) => {
                        ctx.strokeText(p, x, y + ((i - ((msg.split('\n')).length - 1) / 2) * data.height))
                        ctx.fillText(p, x, y + ((i - ((msg.split('\n')).length - 1) / 2) * data.height))
                    })
                }
                else {
                    ctx.strokeText(msg, x, y)
                    ctx.fillText(msg, x, y)
                }
            }
            rectMode = (m) => data['rect'] = m
            ellipseMode = (m) => data['ellipse'] = m
            textAlign = (x, y) => {
                ctx.textAlign = x <= 0 ? 'start' : 'center'
                ctx.textBaseline = y <= 0 ? 'alphabetic' : 'middle'
            }
            createFont = (font) => font
            textSize = size => {
                data.height = size
                ctx.font = `${size}px ${data.font}`
            }
            textFont = (font, size) => {
                data.height ||= size
                data.font = font
                ctx.font = `${data.height}px ${font}`
            }
            strokeCap = mode => ctx.lineCap = mode
            strokeJoin = mode => ctx.lineJoin = mode
            strokeWeight = weight => ctx.lineWidth = Number(weight)
            pushMatrix = () => ctx.save()
            popMatrix = () => ctx.restore()
            resetMatrix = popMatrix
            translate = (x, y) => ctx.translate(x, y)
            rotate = ang => ctx.rotate(degrees(ang))
            scale = (w, h) => ctx.scale(w, h ? h : w)
            beginShape = () => v = []
            vertex = (x, y) => v.push([x, y, 'v'])
            curveVertex = (cx, cy, x, y) => v.push([cx, cy, 'c', x, y])
            bezierVertex = (cx, cy, cX, cY, x, y) => v.push([cx, cy, 'b', cX, cY, x, y])
            endShape = (end) => {
                if(v.length < 2) return
                ctx.beginPath()
                for(let i = 0; i < v.length; i++){
                    let p = v[i]
                    if(i <= 0){
                        if(p[2] !== ('v' || 'c')) return
                        ctx.moveTo(p[0], p[1])
                    }
                    else {
                        switch(p[2]){
                            case 'v':
                                ctx.lineTo(p[0], p[1])
                            break
                            case 'c':
                                ctx.quadraticCurveTo(p[0], p[1], p[3], p[4])
                            break
                            case 'b':
                                ctx.bezierCurveTo(p[0], p[1], p[3], p[4], p[5], p[6])
                        }
                    }
                }
                if(end) ctx.closePath()
                ctx.stroke()
                ctx.fill()
            }
            curve = function(x, y, cx, cy, cX, cY, X, Y) {
                if(arguments.length !== 8) return
                beginShape()
                vertex(x, y)
                curveVertex(cx, cy, cX, cY)
                vertex(X, Y)
                endShape()
            }
            bezier = function(x, y, cx, cy, cX, cY, X, Y) {
                if(arguments.length !== 8) return
                beginShape()
                vertex(x, y)
                bezierVertex(cx, cy, cX, cY, X, Y)
                endShape()
            }
            arc = (x, y, w, h, start, stop) => {
              ctx.beginPath()
              ctx.ellipse(x, y, w * 0.5, h * 0.5, degrees(start), degrees(stop), false)
              ctx.fill()
              ctx.stroke()
            }
            ellipse = (x, y, w, h) => {
                ctx.beginPath()
                ctx.ellipse(x, y, w * 0.5, h * 0.5, 0, 0, Math.PI * 2, true)
                ctx.stroke()
                ctx.fill()
            }
            quad = (x, y, X, Y, _x, _y, _X, _Y) => {
                beginShape()
                vertex(x, y)
                vertex(X, Y)
                vertex(_x, _y)
                vertex(_X, _Y)
                endShape(CLOSE)
            }
            triangle = (x, y, X, Y, _x, _y) => {
                beginShape()
                vertex(x, y)
                vertex(X, Y)
                vertex(_x, _y)
                endShape(CLOSE)
            }
            point = (x, y) => {
                if(!Object.is(ctx.strokeStyle, 'rgba(0, 0, 0, 0)')){
                    let style = ctx.strokeStyle
                    noStroke()
                    ellipse(x, y, ctx.lineWidth, ctx.lineWidth)
                    ctx.strokeStyle = style
                }
                else {
                    return
                }
            }
            line = (x, y, X, Y) => {
                ctx.beginPath()
                ctx.moveTo(x, y)
                ctx.lineTo(X, Y)
                ctx.closePath()
                ctx.stroke()
            }
            textWidth = (txt) => {
                let width = 0
                txt.split('\n').map(str => width = max(width, ctx.measureText(txt).width))
                return width
            }
            textAscent = () => ctx.measureText('a').fontBoundingBoxAscent
            textDescent = () => ctx.measureText('a').fontBoundingBoxDescent
            const Canvas = (w, h) => {
                const C = Object.assign(document.createElement('canvas'), {width: w, height: h})
                return [C, C.getContext('2d')]
            }
            get = function(x, y, w, h, src){
                let canv, data, context, Canv
                switch(arguments.length){
                    case 0:
                        get(0, 0, width, height)
                    break
                    case 2:
                        data = ctx.getImageData(x, y, 1, 1).data
                        return color(data[0], data[1], data[2], data[3])
                    break
                    case 3:
                        Canv = Canvas(w.width, w.height)
                        context = Canv[1]
                        if(w instanceof HTMLImageElement){
                            context.drawImage(w, 0, 0)
                            data = context.getImageData(x, y, 1, 1)
                        }
                        else {
                            data = w.getContext('2d').getImageData(x, y, 1, 1).data
                        }
                        return color(data[0], data[1], data[2], data[3])
                    break
                    case 4:
                        Canv = Canvas(w, h)
                        canv = Canv[0]
                        context = Canv[1]
                        context.putImageData(ctx.getImageData(x, y, w, h), 0, 0)
                        return canv
                    break
                    case 5:
                        Canv = Canvas(src.width, src.height)
                        context = Canv[1]
                        context.drawImage(src, -x, -y)
                        return Canv[0]
                    break
                    default:
                        return
                }
            }
            mask = ctx.clip
            image = (img, x, y, w, h) => {
              ctx.drawImage(img, x, y, w || img.width, h || img.height)
            }
            //]
            //interaction [
            //mouse [
            mousePressed = () => {}
            mouseReleased = () => {}
            mouseScrolled = () => {} 
            mouseClicked = () => {} 
            mouseOut = () => {}
            mouseOver = () => {}
            mouseMoved = () => {}
            mouseIsPressed = false
            mouseButton = left
            mouseX = 0
            mouseY = 0
            pmouseX = mouseX
            pmouseY = mouseY
            canvas.onmousedown = e => {
                mousePressed(e)
                mouseIsPressed = true
                mouseButton = e.button
            }
            canvas.onmousemove = e => {
                pmouseX = mouseX
                pmouseY = mouseY
                mouseX = floor(e.offsetX * width / canvas.clientWidth)
                mouseY = floor(e.offsetY * height / canvas.clientHeight)
                // console.log(e)
                mouseMoved(e)
            }
            canvas.onmouseup = e => {
                mouseReleased(e)
                mouseClicked(e)
                mouseButton = e.button
                mouseIsPressed = false
                e.preventDefault()
            }
            canvas.oncontextmenu = e => e.preventDefault()
            canvas.onmouseover = e => {
                e.preventDefault()
                mouseOver(e)
            }
            canvas.onmouseout = e => {
                e.preventDefault()
                mouseOut(e)
            }
            canvas.onwheel = e => {
                e.preventDefault()
                mouseScrolled(e)
            }
            //]
            //keys [
            keyPressed = function(){}
            keyReleased = function(){}
            keyTyped = function(){}
            document.onkeydown = e => {
                e.preventDefault()
                key = e.key
                keyCode = e.keyCode
                keyIsPressed = true
                keyPressed(e)
            }
            document.onkeyup = e => {
                e.preventDefault()
                key = e.key
                keyCode = e.keyCode
                keyReleased(e)
            }
            document.onkeypress = e => {
                e.preventDefault()
                key = e.key
                keyCode = e.keyCode
                keyTyped(e)
            }
            //]
            //]
            let loopy
            if(loopy) window.clearInterval(loopy)
            loopy = window.setInterval(() => {
                draw()
                frameCount += 1
                fps = frameCount % 10 <= 0 ? 1000 / (Date.now() - data.date) : fps
                data.date = Date.now()
                data.millis = Date.now() - data.last
            }, 1000 / data.rate)
            //]
            //print logic [
            let print = document.getElementsByClassName('print')[0]
            print.onclick = e => {
                if(e.path[0].classList.contains('close')){
                    clearLogs()
                    print.style.display = 'none'
                }
            }
            //]
        </script>
        <!-- platformer here -->
        <script type = 'module'>
        /** Constants */
        const BLOCK_SIZE = 75
        const GRAVITY = 0.5
        
         /** Level setup */
        //{
        const levels = [
          {
              map: [
                  "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm",
                  "m             ^               m",
                  "m         mmmmmmmmmm          m",
                  "m       m mmmmmmmmmmm         m",
                  "m     ^   mmmmmmmmmmmm    ^   m",
                  "m  ^     mmmmmmmmmmmmmm       m",
                  "m@    m   mmmmmmmmmmmmmm       ",
                  "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm"
              ],
              cameraSetup: [
                { angle: 0, sequence: [['rotate', 300, Math.PI], ['wait', 100], ['rotate', 300, -Math.PI], ['wait', 100]]},
                { angle: Math.PI / 2, sequence: [['rotate', 200, Math.PI / 2], ['wait', 50], ['rotate', 200, -Math.PI / 2], ['wait', 50]]},
                { angle: Math.PI / 2, sequence: [['rotate', 200, Math.PI / 2], ['wait', 50], ['rotate', 200, -Math.PI / 2], ['wait', 50]]}
              ],
              messages: [
                "A secret mission",
                "You can wall jump",
                "One that you alone\ncan achieve",
                "You have a mission",
              ]
          },
          {
            map: [
              "mmmmmmmmmmmmmmmmmmmmmmmmmmmm",
              "mmmmmmmmmm        mmmmmmmmmm",
              "mmmmmm                mmmmmm",
              "mmm           m mmmmm    mmm",
              "mm            m m  &      mm",
              "m    ^        m m          m",
              "m@                 ^        ",
              "mmmmmmmmmmmmmmmmmmmmmmmmmmmm"
            ],
            messages: [
              "Some would call you noble",
              "Avoid cameras"
            ],
            cameraSetup: [
                { angle: Math.PI / 2, sequence: ['wait', 200] }
            ]
          },
          {
            map: [
              "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm",
              "m                              ",
              "m                             m",
              "m                            mm",
              "m                           mmm",
              "m   ^                      mmmm",
              "m@           ^       g    mmmmm",
              "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm"
            ],
            messages: [ "Others, a villian", 'Look out for guards']
          },
          {
            map: [
              "mmmmmmmmmmmmmmm",
              "m             m",
              "mg           gm",
              "mm           mm",
              "m      ^       ",
              "m    #        m",
              "m@   ##       m",
              "mmmmmmmmmmmmmmm" 
            ],
            messages: [
              "Your life is in danger"
            ]
          },
          {
            map: [
              "mmmmmmmmmmmmmm",
              "m         g  m",
              "m         m   ",
              "m@   ^       m",
              "mm         m m",
              "mm m   m  mm m",
              "mm m   m  mm m",
              "mm m   m  mm m",
              "mm m   m  mm m",
              "mm m   m  mm m",
              "mm m   m  mm m",
            ],
            messages: [
              "They want to trap you"
            ]
          },
          {
            map: [
              "mmmmmmmmmmmmmmm",
              "m &           m",
              "m             m",
              "mm  ^          ",
              "m@         g  m",
              "mmmmm   g  m  m",
              "mmmmm   m  m  m",
              "mmmmmmmmmmmmmmm",
            ],
            cameraSetup: [
              { 
                angle: Math.PI / 2, 
                sequence: [['wait', 50], ['rotate', 200, -Math.PI / 2], ['wait', 50], ['rotate', 200, Math.PI / 2]]
              }
            ],
            messages: [ "They lie in wait" ]
          },
          {
            map: [

                "mmmmmmmmmmmmmmmmmmmmmmm",
                "m         & &         m",
                "m                     m",
                "m         m mmmmmmmmm m",
                "m        mm mm        m",
                "m       mmm mmm       m",
                "m  ^   mmmm mmmm      m",
                "m     mmmmm mmmmm     m",
                "m    mmmmmm mmmmmm    m",
                "m   mmmmmmm mmmmmmm   m",
                "m  mmmmmmmm mmmmmmmm  m",
                "m@mmmmmmmmggggggggmmm ",
                "mmmmmmmmmmmmmmmmmmmmmmm"
            ],
            cameraSetup: [{
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
            ],
            messages: [ "They deceive" ]
        },
          {
              map: [
                  "mmmmmmmmmmmmmmmmmmmmmmm",
                  "m                      ",
                  "m& #                  m",
                  "m  mmmmmmmmmmmmmmmmm  m",
                  "m  m   #        #     m",
                  "m^ m   # gggggg #     m",
                  "m  m  mmmmmmmmmmmmmmmmm",
                  "m ^m   #        #     m",
                  "m  m   # gggggg #     m",
                  "m^ mmmmmmmmmmmmmmmmm  m",
                  "m  m                  m",
                  "m          @          m",
                  "mmmmmmmmmmmmmmmmmmmmmmm"
              ],
              cameraSetup: [{
                  angle: 0,
                  sequence: [
                      ['rotate', 200, Math.PI * 1]
                  ]
              }],
              messages: ["up", "up","up"]
          },
          {
              map: [
                  "mmmmmmmmmmmmmmmmmmmmmmm",
                  "m    &     &     &    m",
                  "m    m     m     m    m",
                  "m                     m",
                  "m@#                 m m",
                  "mmm  m  m  m  m  m  m m",
                  "m    ^              m m",
                  "m g g g g g g g g m   m",
                  "m g g g g g g g g m m m",
                  "mmmmmmmmmmmmmmmmmmmmm m",
                  "m                     m",
                  "m  mmmmmmmmmmmmmmmmmmmm",
                  "m                     m",
                  "m     #         #      ",
                  "mmmmmmmmmmmmmmmmmmmmmmm"
              ],
              cameraSetup: [{
                      angle: 0,
                      sequence: [
                          ['rotate', 200, Math.PI * 1]
                      ]
                  },

                  {
                      angle: 0,
                      sequence: [
                          ['rotate', 200, Math.PI * 1]
                      ]
                  },

                  {
                      angle: 0,
                      sequence: [
                          ['rotate', 200, Math.PI * 1]
                      ]
                  },
                  {
                      angle: 0,
                      sequence: [
                          ['rotate', 200, Math.PI * 2]
                      ]
                  },
              ],
              messages: ["The odds are stacked\nagainst you"]
          },
          {
              map: [
                  "mmmmmmmmmmmmmmmmmmmmmmm",
                  "m@ #   m               ",
                  "mmmmmm mmm mmmmmmmmmmmm",
                  "m  &   m     mmmmmmmmmm",
                  "m      mm #           m",
                  "m mmmmmmm mmm   m  g  m",
                  "m m   &    mmm  mmmmmmm",
                  "m m  mmmmmmmmmm       m",
                  "m m        mmmmm      m",
                  "m mmmmmmm  mmmmmm  mmmm",
                  "m mm  &   mmmmmmmm    m",
                  "m mmm  m  gmmmmmmmm   m",
                  "m mmm mmmmmmmmmmmmmm  m",
                  "m  m         &     m  m",
                  "m  mm   #             m",
                  "m      ### #   g g    m",
                  "mmmmmmmmmmmmmmmmmmmmmmm"
              ],
              cameraSetup: [
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: Math.PI / 2,
                    sequence: [
                        ['rotate', 200, Math.PI / 2],
                        ['wait', 50],
                        ['rotate', 200, -Math.PI / 2],
                        ['wait', 50]
                    ]
                }
              ]
          },
          {
            map: [
            "mmmmmmmmmmmmmmmmmmmm",
            "m@  m               ",
            "m ^ m  mmm mmmmmmmmm",
            "m   m              m",
            "m   m     m        m",
            "m   m   # &        m",
            "m   m   #     #    m",
            "m   m   m     m   mm",
            "m   m ^       mm   m",
            "m   m         m  # m",
            "m   mmmmmmmmmmm  mmm",
            "m   m      ^       m",
            "m   m           #  m",
            "m   m           mmmm",
            "m   m m   mmmmmm   m",
            "m   m              m",
            "m   mmmmmmmm       m",
            "m   #         mm   m",
            "mm  m     ^       mm",
            "mm g g g g   g g#  m",
            "mmmmmmmmmmmmmmmmmmmm",

            ],
            cameraSetup: [
            { angle: 0, sequence: [['rotate', 200, Math.PI * 1]]},


            ],
            messages: [
                "Falling!",
                "Hide!",
                "Climb!",
                "These guards haven't been fed in days."
                ]
            },
          {
            map: [
              "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm",
              "mmmmmm   ^                ^   m",
              "mmmmmmm    mmmmmmmmmmmmmmmmmmmm",
              "mmmmmmm   mmmmmmmmmmmmmmmmmmmmm",
              "mmmmm   mmmmmmmmmmmmmmmmmmmmmmm",
              "mmmmm mmmmmmmmmmmmmmmmmmmmmmmmm",
              "mmmmm               mmmmmmmmmmm",
              "mmmmmmmmmmmmmm      mmmmmmmmmmm",
              "mmmmmmmmmmmmmmmmmmm  mmmmmmmmmm",
              "m             m &^ m          m",
              "m     m    mm mmmmmmmmmmmmmm  m",
              "m     m   mmm mmmmm   mmmmmm  m",
              "m  &     mmmm # # # # mmmmmm  m",
              "m         mmmmm m m m m        ",
              "m@    mm  mmmmmmmmmmm   m   &mm",
              "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm"
            ],
            cameraSetup: [
              { angle: 0, sequence: [['rotate', 300, Math.PI], ['wait', 100], ['rotate', 300, -Math.PI], ['wait', 100]]},
              { angle: Math.PI / 2, sequence: [['rotate', 200, Math.PI / 2], ['wait', 50], ['rotate', 200, -Math.PI / 2], ['wait', 50]]},
              { angle: Math.PI / 2, sequence: [['rotate', 200, Math.PI / 2], ['wait', 50], ['rotate', 200, -Math.PI / 2], ['wait', 50]]}
            ],
            messages: [
              "Why are you up Here?",
              "Trolled >:)",
              "?"
            ]
          },
          {
              map: [
                "mmmmmmmmmmmmmmmmm",
                "m@              m",
                "mmmmmm mmmmmmmm m",
                "m      m        m",
                "m      m        m",
                "m      &        m",
                "m    |||||      m",
                "m    | ^ |      m",
                "m    |   |      m",
                "m    | * |      m",
                "m    mmmmm      m",
                "mmmmmmmmmmm   mmm",
                "mm            m  ",
                "mm mmmmmmmmmmmm m",
                "mm mmmmmmmmmmmm m",
                "mm       ^      m",
                "mmmmmmmmmmmmmmmmm",
              ],
              messages: ['What?',"It's a fake"],
              cameraSetup: [
                { angle: Math.PI / 2, sequence: [['wait', 100]] }   
              ]
          },
          {
              map: [
                "mmmmmmmmmmmmmmmm",
                "m   m  & gm    m",
                "m   m    mm    m",
                "m   m     m    m",
                "m    g mm m    m",
                "m mmmm m  m    m",
                "m   m  m mm    m",
                "m   m mm  m    m",
                "m   m  mm m    m",
                "m   mm m  mg  gm",
                "m   m  m mmm  mm",
                "m@  ^ mm        ",
                "mmmmmmmmmmmmmmmm",
              ],
              messages: ["Climb"],
              cameraSetup: [
                { 
                    angle: 0, 
                    sequence: [
                        ['wait', 100],
                        ['rotate', 200, Math.PI], 
                        ['wait', 100], 
                        ['rotate', 200, -Math.PI]
                    ]
                },
            ]
          },
          {
              map: [
                "mmmmmmmmmmmmmmmmmmmm",
                "m  &    &    &     m",
                "m                  m",
                "mm                 m",
                "m@ ^        ^ #    m",
                "mmmmmmmmmmmmmmmmmm m",
                "mg    g            m",
                "mm    m            m",
                "m     m            m",
                "m m   m            m",
                "m m   m            m",
                "m m             ^  m",
                "m mmmmmmmmmmmmmmmmmm",
                "m                  m",
                "m                  m",
                "m               m  m",
                "m       |||||      m",
                "m  ^   |||||||     m",
                "m     m|||||||m    m",
                "m    mm|||&|||mm    ",
                "mmmmmmmmmmmmmmmmmmmm",
              ],
              messages: ["Patience","Run!",'Phew',"You're getting close"],
              cameraSetup: [
                {
                    angle: Math.PI,
                    sequence: [
                        ['wait',50],
                        ['rotate',150,-Math.PI],
                        ['wait', 100],
                        ['rotate',150,Math.PI],
                    ]
                },    
                {
                    angle: Math.PI,
                    sequence: [
                        ['wait',75],
                        ['rotate',150,-Math.PI],
                        ['wait', 75],
                        ['rotate',150,Math.PI],
                    ]
                },  
                {
                    angle: Math.PI,
                    sequence: [
                        ['wait',100],
                        ['rotate',150,-Math.PI],
                        ['wait', 50],
                        ['rotate',150,Math.PI],
                    ]
                },  
                {
                    angle: 0,
                    sequence: [
                        ['wait',20],
                        ['rotate',100,-Math.PI],
                        ['wait', 100],
                        ['rotate',130,Math.PI],
                    ]
                },  
              ],
          },
          {
            map: [
                "mmmmmmmmmmmmmmmmmmmmmmmmm",
                "m         m ^ mmmmmmmm   ",
                "m mmmm ## m @ mm    mm mm",
                "m mmmm mmmm   mm    mm mm",
                "m mmmm mmmm   mm #  mm mm",
                "m mmmm mmmm   mm### mm mm",
                "m m    mmmg   gm####mm mm",
                "m m    mmmmm mmmmmmmmm mm",
                "m m        g g         mm",
                "m m    mmmmm mmmmmmmmm mm",
                "m m    mmmmg gmmmmm    mm",
                "m mmmmmmmmmm mmmmmm    mm",
                "m mmmmmmmmmg gmmmmm    mm",
                "m mmmmmmmmmm mmmmmm    mm",
                "m mmmmmmmmmg gmmmmm    gm",
                "m^mmmmmmmmmm mmmmmm    mm",
                "m^mmmmmmmmmg gmmmmm    gm",
                "m^mmmmmmmmmm mmmmmm    mm",
                "m^mmmmmmmmmg gmmmmm    mm",
                "m^mmmmmmmmmm mmmmmm    mm",
                "m                      mm",
                "mmmmmmmmmmmmmmmmmmmmmmmmm",
            ],
            messages: ["freefall",'c','l','i','m','b']
          },
          {
              map: [
                "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm",
                "m@    ^            m      &       &m              mmm  g  &m",
                "mmmmmm mmmmmmmmmmmmm    #    m            mmmmmmm  mm&mm   m",
                "m          mmmmmmmmmm  mmmmmmmmmmmmm      m     mm         m",
                "m  mmmmmmm  mmm   mmmm             mg    gmggg ggg mmmmm   m",
                "m        mm  m  m  mmmmmmmmmmmmmm  mmm mmmmmmm mmmmm   m   m",
                "mmmmmmm   mm   mmm                #m                   #   m",
                "m         mmmmmmmmm  g    g #     #m mm  mmmmmmmmmmmm  mmmmm",
                "m mmmmm mmmmmmmmmmmmmmmmmmmmmmmmmmmm # m  m      &     m   m",
                "m     m   m   &     &      &    &  mmm mm              m   m",
                "mmmm  m   m            ^           m   mmmm   g g g g  m   m",
                "m  m  mmm mmmmmmmmmmmmmm       mmmmm   mmmm  mmmmmmmmmmm   m",
                "m  m  m   m                       &m mmmmm  mm         m   m",
                "m &   m   m  mmmmmmmmmmmmmmmmm     m   m   mmm  mmmmm  m   m",
                "m  m  m   m  mmmmmmmmmmm  &  mm           mmm     mmm  m   m",
                "m  m  m mmm  mgg ggm         mmmmmmmmmmmmmmmm     mmm  m   m",
                "m  m  m   m  mmm mmm  mm                  mmm     mmm  m   m",
                "m  m  m   m  mgg ggm  mm  mmmmmmmmmmmmmmgm          mmmm   m",
                "m  m  m   m  mmm mmm  mm           m   mgm  mmmmmmm        m",
                "m  m  m   m  mgggggm  mmmmmmmmmm       mgm  mmmmmmmmmmmmmmmm",
                "m         m  mgggggm  mm &      #  mmm mgm  m  gg  mm  m   m",
                "m     #mmmm  mgggggm  mm    mmmmmmmm   mgm  m  mm  mm  m   m",
                "m   # #   mggggggggm        m   g  m   mgm  m      mm  m   m",
                "mmmmmmm   mmmmmmmmmmmmmm    mmmmm  m   mgg  gggggggmm  m   m",
                "mmmmmmm       mmmmmmmmmmm   m   g  m   mmmmmmmmmmmmmm  m   m",
                "mmmmmmm mmmmm  mmmmmm   mmmmm   mmm      mg               mm",
                "mmmmmmm   mmmm  mmmm                     mmmmmmmmmmmm    mmm",
                "mmmmmmmmm mmmmm  mm  mmmmmm   mm                         mmm",
                "m*        mmmmmm    mmmmgggggggmm    #      g   g        mmm",
                "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm"
              ],
              cameraSetup: [
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
                {
                    angle: 0,
                    sequence: [
                        ['rotate', 200, Math.PI * 1]
                    ]
                },
              ],
              messages: [
                "The maze of security",
                "We're watching you",
              ]
          },
        ]
        
        let currentLevel;
        function loadLevel() {
            const level = currentLevel || levels[levelIndex]
            clearData()
            const levelMap = level.map
            const levelWidth = levelMap[0].length
            const levelHeight = levelMap.length
            initTileData(levelWidth, levelHeight)
            let cameraIndex = 0, messageIndex = 0
            let playerX = 0, playerY = 0
            for(var i = 0; i < levelHeight; i++) {
                for(var j = 0; j < levelWidth; j++) {
                    const symbol = levelMap[i][j]
                    switch(symbol) {
                        case "m":
                        case "r":
                        case "|":
                            putTileData(j, i, symbol)
                        break;
                        case "&":
                            const param = level.cameraSetup[min(cameraIndex++, level.cameraSetup.length - 1)]
                            cameras.push(new EnemyCamera(j * BLOCK_SIZE + BLOCK_SIZE * 0.5, i * BLOCK_SIZE + BLOCK_SIZE * 0.5, param.angle, param.sequence))
                        break;
                        case "@":
                            playerX = j * BLOCK_SIZE + BLOCK_SIZE * 0.25
                            playerY = i * BLOCK_SIZE + BLOCK_SIZE * 0.25
                        break;
                        case "#":
                            new Crate(j * BLOCK_SIZE, i * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        break;
                        case "g":
                          new Guard(j * BLOCK_SIZE + BLOCK_SIZE * 0.25, i * BLOCK_SIZE + BLOCK_SIZE * 0.25, BLOCK_SIZE * 0.5, BLOCK_SIZE * 0.5)
                        break;
                        case "*":
                          new Portal(j * BLOCK_SIZE, i * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE)
                        break;
                        case "^":
                          levelMessages.push(new LevelMessage(level.messages[min(messageIndex++, level.messages.length - 1)], j * BLOCK_SIZE + BLOCK_SIZE / 2, i * BLOCK_SIZE + BLOCK_SIZE / 2))
                        break;
                    }
                }
            }
            player = new Player(playerX, playerY, BLOCK_SIZE * 0.5, BLOCK_SIZE * 0.5)
            cam.x = player.center.x - width / 2
            cam.y = player.center.y - height / 2
            cam.setBounds({
                minX: 0, minY: 0,
                maxX: levelWidth * BLOCK_SIZE,
                maxY: levelHeight * BLOCK_SIZE
            })
            
            levelLoaded = true  
          }
        const howToLevel = {
          map: [
            "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm",
            "m      ^            ^         m",
            "m   mmmmmmmmmmmmmmmmm         m",
            "mm        ^         m         m",
            "mmmmmmmmmmmmmmmmm   m         m",
            "m                  mm         m",
            "m           mmmm mmm          m",
            "m  ^    m mmm ^  mmm          m",
            "m@     ^  mmm #  mmm          m",
            "mmmmmmmmmmmmmmmmmmmm          m",
            "mmmmmmmmmmmmmmmmmmmm          m",
          ],
          messages: ["Tunnels", "Leap of faith","What brought you here?", "Welcome, brave spy", "Crate","You can jump off of walls"]
        }
        //}
        let levelIndex = 0//levels.length - 1
        let completedLevels = localStorage.getItem("NINJA_VIGIL/completedLevels") || 0
        let levelLoaded = false

        
        /** SETUP */
        const keys = []
        function keyIsDown(...keyCodes) {
           return keyCodes.some(code => keys[code])
        }
        keyPressed = function() {
           keys[keyCode] = true
        }
        keyReleased = function() {
           keys[keyCode] = false
        }
        rectMode(CORNER)
        angleMode(RADIANS)
        /** END SETUP */
        
        /** Helper functions */
        function getCenteredText(txt, x, y, w, h) {
          const spaceWidth = ctx.measureText(' ').width
          const words = txt.split(' ').map(word => {
            return {
              w: ctx.measureText(word).width,
              word
            }
          })
          let newStr = ''
          let currentWidth = 0
          for(const word of words) {
            currentWidth += word.w
            if(currentWidth > w) {
              currentWidth = 0
              newStr += '\n'
            }
            currentWidth += spaceWidth
            newStr += word.word + " "
          }
          return newStr
        }
        function cache(w, h, cb, type) {
            const canvas = document.createElement('canvas')
            canvas.width = w
            canvas.height = h
            const ctx = canvas.getContext('2d')
            cb(canvas, ctx, w, h)
            if(type === 'pattern') {
                const pattern = ctx.createPattern(canvas, 'repeat')
                pattern.width = w
                pattern.height = h
                return pattern
            }
            return canvas
        }
        const normAngle = angle => {
            while(angle < -Math.PI) {
                angle += Math.PI * 2
            }
            while(angle > Math.PI) {
                angle -= Math.PI * 2
            }
            return angle
        }
        
        /** Image Loading */
        const img = {
            imgs: {
                box() {
                    pushMatrix();
                    translate(36, 36)
                    scale(3);
                    rectMode(CENTER);
                    strokeWeight(6);
                    stroke(115, 61, 0);
                    fill(163, 73, 0);
                    rect(0, 0, 18, 18);
                    strokeWeight(2);
                    line(-8, -8, 8, 8);
                    line(-8, 8, 8, -8);
                    stroke(100, 100, 100);
                    strokeWeight(1);
                    point(-9, -9);
                    point(-9, -11);
                    point(-11, -9);
                    point(-11, -11);
                    point(8, -9);
                    point(8, -11);
                    point(10, -9);
                    point(10, -11);
                    point(-9, 8);
                    point(-9, 10);
                    point(-11, 8);
                    point(-11, 10);
                    point(8, 8);
                    point(8, 10);
                    point(10, 8);
                    point(10, 10);
                    popMatrix();
                    return get(0, 0, 72, 72)
                },
                metal() {
                    clear()
                    pushMatrix();
                    translate(80, 80);
                    scale(1.35, 1.35);
                    translate(-247.5, -112.5);
                    rectMode(0)
                    noStroke();
                    fill(99, 99, 99);
                    rect(189,54,120,120);
                    
                    stroke(99, 99, 99);
                    strokeWeight(3);
                    fill(153, 153, 153);
                    
                    rect(227,55,50,50);
                    rect(256,77,50,50);
                    rect(257,55,50,50);
                    rect(257,125,50,47);
                    rect(229,110,64,29);
                    rect(226,139,50,33);
                    rect(190,55,50,29);
                    rect(211,68,50,50);
                    rect(190,55,24,50);
                    rect(201,87,29,37);
                    rect(191,79,10,50);
                    rect(190,122,50,50);
                    
                    fill(184, 184, 184);
                    noStroke();
                    
                    rect(192,124,46,4);
                    rect(235,124,4,46);
                    rect(242,166,33,4);
                    rect(279,141,16,4);
                    rect(295,127,11,4);
                    rect(264,107,40,2);
                    rect(263,112,29,4);
                    rect(232,120,31,2);
                    rect(217,70,42,4);
                    rect(260,57,45,4);
                    rect(192,57,20,4);
                    rect(193,81,6,4);
                    rect(203,89,25,4);
                    rect(216,57,4,9);
                    rect(242,62,13,4);
                    fill(0, 200)
                    rect(188, 53, 122, 122)
                    popMatrix();
                    return get(0, 0, 152, 152)
                },
                rust() {
                    clear()
                    pushMatrix();
                    translate(81, 81);
                    scale(1.37);
                    translate(-247.5, -112.5);
                    noStroke();
                    rectMode(0)
                    fill(138, 51, 51);
                    rect(189,54,120,120);
                    
                    stroke(138, 51, 51);
                    strokeWeight(3);
                    fill(184, 84, 77);
                    
                    rect(227,55,50,50);
                    rect(256,77,50,50);
                    rect(257,55,50,50);
                    rect(257,125,50,47);
                    rect(229,110,64,29);
                    rect(226,139,50,33);
                    rect(190,55,50,29);
                    rect(211,68,50,50);
                    rect(190,55,24,50);
                    rect(201,87,29,37);
                    rect(191,79,10,50);
                    rect(190,122,50,50);
                    
                    fill(219, 113, 92);
                    noStroke();
                    
                    rect(192,124,46,4);
                    rect(235,124,4,46);
                    rect(242,166,33,4);
                    rect(279,141,16,4);
                    rect(295,127,11,4);
                    rect(264,107,40,2);
                    rect(263,112,29,4);
                    rect(232,120,31,2);
                    rect(217,70,42,4);
                    rect(260,57,45,4);
                    rect(192,57,20,4);
                    rect(193,81,6,4);
                    rect(203,89,25,4);
                    rect(216,57,4,9);
                    rect(242,62,13,4);
                    
                    popMatrix();
                    return get(0, 0, 150, 150)
                },
                fakeCam() {
                  clear()
                  pushMatrix();
                  translate(103, 105);
                  scale(3)
                  // Lights {
                  translate(275, 248);
                  pushMatrix();
                      translate(-274, -247);
                      rotate(0);
                      
                      noStroke();
                      
                      fill(50);
                      rectMode(CENTER);
                      rect(0, 0, 30, 20, 3);
                      
                      rect(9, 0, 30, 10, 2);
                      
                      fill(80);
                      ellipse(-13.6, 0, 3, 20);
                      
                      fill(150, 255, 150, 150);
                      ellipse(-3, 6, 3, 3);
                      
                      fill(0, 255, 0, 50);
                      ellipse(-3, 6, 6, 6);
                      
                      // fill(255, 255, 0, 60);
                      // arc(399, 0, 750, 100, 91, 270);
                      // arc(399, 0, 50, 100, -89, 90);
                      
                      fill(130);
                      rect(-3, -4, 10, 8);
                      
                      fill(255, 100);
                      ellipse(23, 0, 2, 10);
                      
                      for (var i = -6; i <= 0; i += 2) {
                          stroke(100);
                          strokeWeight(1);
                          line(i, -2, i, -6);
                      }
                      
                      noStroke();
                      
                  popMatrix();
                  popMatrix();
                  return get(17, 13, 197, 197)
                },
                backgroundImage() {
                  var lightFade2 = 100;
                  var lighton2 = false;
                  
                  var lightFade1 = 100;
                  var lighton1 = false;
                  
                  var ninja = function (x, y, s, r) {
                  
                  pushMatrix();
                  scale(s);
                  translate(x,y);
                  rotate(r);
                  
                  noStroke();
                  fill(0, 0, 0);
                  
                  rect(107,103,200,200);
                  
                  fill(217, 130, 76);
                  rect(153,153,154,50);
                  
                  fill(168, 0, 0);
                  rect(107,133,200,20);
                  
                  fill(64, 64, 64);
                  rect(107,251,200,20);
                  
                  stroke(168, 0, 0);
                  strokeWeight(10);
                  line(86,175,111,140);
                  line(66,160,111,138);
                  
                  fill(0, 0, 0);
                  noStroke();
                  ellipse(218, 173, 20, 17);
                  ellipse(282, 173, 20, 17);
                  
                  stroke(0, 0, 0);
                  strokeWeight(3);
                  line(236, 169, 197, 159);
                  line(297, 168, 268, 163);
                  
                  popMatrix();
                  
                  }; // This is faith's code
                  var badguy = function (x, y, s) {
                  
                  pushMatrix();
                  scale(s);
                  translate(x,y);
                  
                  noStroke();
                  fill(64, 64, 64);
                  
                  rect(107,103,200,200);
                  
                  fill(161, 157, 155);
                  rect(107,153,200,50);
                  
                  fill(64, 64, 64);
                  rect(87,133,240,20);
                  
                  fill(64, 64, 64);
                  rect(107,251,200,20);
                  
                  fill(0, 0, 0);
                  noStroke();
                  ellipse(170,176,40,40);
                  ellipse(260,176,40,40);
                  
                  stroke(0, 0, 0);
                  strokeWeight(3);
                  line(108,176,305,176);
                  
                  fill(0, 0, 0);
                  rect(257,247,27,35);
                  rect(277,239,7,35);
                  
                  fill(36, 36, 36);
                  noStroke();
                  rect(108,254,199,19);
                  
                  popMatrix();
                  
                  }; // This is faith's code
                  var securityCamera1 = function (x, y, r, s) {
                      pushMatrix();
                          translate(x, y);
                          scale(s);
                          
                          // Lights {
                          
                          pushMatrix();
                              translate(-510, 40);
                              rotate(87);
                              
                              stroke(0);
                              strokeWeight(3);
                              line(-275, -279, -275, -254);
                              
                              noStroke();
                              fill(80);
                              arc(-275, -283, 15, 10, 0, 180);
                              arc(-275, -282.7, 15, 4, -180, 0);
                              
                          popMatrix();
                          
                          pushMatrix();
                              translate(-274, -247);
                              rotate(r);
                              
                              noStroke();
                              
                              fill(50);
                              rectMode(CENTER);
                              rect(0, 0, 30, 20, 3);
                              
                              rect(9, 0, 30, 10, 2);
                              
                              fill(80);
                              ellipse(-13.6, 0, 3, 20);
                              
                              fill(150, 255, 150, 150);
                              ellipse(-3, 6, 3, 3);
                              
                              fill(0, 255, 0, lightFade2);
                              ellipse(-3, 6, 6, 6);
                              
                              fill(255, 255, 0, 60);
                              arc(197, 0, 350, 70, 91, 270);
                              arc(197, 0, 30, 70, -89, 90);
                              
                              fill(130);
                              rect(-3, -4, 10, 8);
                              
                              fill(255, 100);
                              ellipse(23, 0, 2, 10);
                              
                              for (var i = -6; i <= 0; i += 2) {
                                  stroke(100);
                                  strokeWeight(1);
                                  line(i, -2, i, -6);
                              }
                              
                              noStroke();
                              
                          popMatrix();
                          
                          // }
                          
                          if (lighton2) {
                              if (lightFade2 >= 100) {
                                  lighton2 = false;
                              } else {
                                  lightFade2 += 3;
                              }
                          } else {
                              if (lightFade2 <= 0) {
                                  lighton2 = true;
                              } else {
                                  lightFade2 -= 3;
                              }
                          }
                          
                          rectMode(CORNER);
                          
                      popMatrix();
                  };
                  var boxes = function (x, y, s) {
                      pushMatrix();
                          translate(x, y);
                          scale(s);
                          
                          rectMode(CENTER);
                          
                          strokeWeight(4);
                          stroke(115, 61, 0);
                          fill(163, 73, 0);
                          rect(0, 0, 20, 20);
                          
                          strokeWeight(2);
                          line(-8, -8, 8, 8);
                          line(-8, 8, 8, -8);
                          
                          stroke(100);
                          strokeWeight(1);
                          point(-9, -9);
                          point(-9, -11);
                          point(-11, -9);
                          point(-11, -11);
                          
                          point(8, -9);
                          point(8, -11);
                          point(10, -9);
                          point(10, -11);
                          
                          point(-9, 8);
                          point(-9, 10);
                          point(-11, 8);
                          point(-11, 10);
                          
                          point(8, 8);
                          point(8, 10);
                          point(10, 8);
                          point(10, 10);
                          
                          rectMode(CORNER);
                          
                      popMatrix();
                  };
                  
                  var graphic = function () {
                      
                      background(100);
                      
                      fill(150);
                      quad(0, 600, 0, 180, 370, 180, 600, 600);
                      
                      fill(120);
                      quad(30, 60, 30, 180, 135, 180, 135, 60);
                      
                      fill(125);
                      quad(600, 0, 375, 0, 370, 180, 600, 600);
                      
                      rectMode(CENTER);
                      fill(200);
                      rect(55, 155, 20, 10);
                      
                      fill(200, 0, 0);
                      rect(55, 153, 18, 4);
                      
                      fill(50);
                      rect(55, 157, 18, 3);
                      
                      fill(200);
                      rect(306, 123, 30, 40);
                      
                      fill(170);
                      rect(306, 123, 22, 32);
                      
                      noStroke();
                      fill(255, 255, 0);
                      beginShape();
                      vertex(303, 136);
                      vertex(310, 125);
                      vertex(312, 125);
                      vertex(314, 114);
                      vertex(309, 113);
                      vertex(306, 125);
                      vertex(304, 125);
                      endShape();
                      
                      // Wires {
                      noFill();
                      stroke(0, 255, 0);
                      beginShape();
                      vertex(316, 102);
                      vertex(316, 84);
                      vertex(181, 84);
                      vertex(181, 14);
                      vertex(93, 14);
                      vertex(93, 0);
                      endShape();
                      
                      stroke(255, 255, 0);
                      beginShape();
                      vertex(313, 102);
                      vertex(313, 87);
                      vertex(178, 87);
                      vertex(178, 17);
                      vertex(90, 17);
                      vertex(90, 0);
                      endShape();
                      
                      stroke(255, 0, 0);
                      beginShape();
                      vertex(310, 102);
                      vertex(310, 90);
                      vertex(175, 90);
                      vertex(175, 20);
                      vertex(15, 20);
                      vertex(15, 150);
                      endShape();
                      
                      stroke(0, 0, 255);
                      beginShape();
                      vertex(307, 102);
                      vertex(307, 93);
                      vertex(172, 93);
                      vertex(172, 23);
                      vertex(18, 23);
                      vertex(18, 150);
                      endShape();
                      // }
                      
                      noStroke();
                      fill(130);
                      rect(194, 88, 10, 20);
                      rect(299, 88, 10, 20);
                      rect(177, 72, 20, 10);
                      rect(177, 32, 20, 10);
                      rect(161, 17, 10, 20);
                      rect(92, 7, 10, 10);
                      rect(75, 21, 10, 10);
                      rect(29, 21, 10, 10);
                      rect(17, 33, 10, 10);
                      
                      fill(50);
                      rect(17, 154, 10, 10);
                      
                      fill(255, 0, 0);
                      ellipse(17, 154, 4, 4);
                      
                      fill(255, 0, 0, 100);
                      ellipse(17, 154, 8, 8);
                      
                      fill(240, 0, 0);
                      rect(405, 257, 16, 60);
                      ellipse(405, 288, 16, 8);
                      
                      fill(255, 0, 0);
                      ellipse(405, 228, 16, 8);
                      rect(400, 261, 4, 60);
                      
                      fill(30);
                      rect(405, 223, 4, 10);
                      ellipse(405, 219, 7, 7);
                      rect(402, 219, 10, 4);
                      
                      noFill();
                      stroke(0);
                      ellipse(409, 216, 7, 7);
                      
                      noStroke();
                      fill(255, 0, 0, 100);
                      rect(490, 175, 20, 15, 4);
                      
                      fill(255, 0, 0, lightFade1);
                      ellipse(490, 175, 14, 10);
                      
                      fill(255, 0, 0, lightFade1 - 180);
                      ellipse(490, 175, 160, 160);
                      
                      fill(100);
                      rect(502, 175, 10, 21, 4);
                      
                      if (lighton1) {
                          if (lightFade1 >= 200) {
                              lighton1 = false;
                          } else {
                              lightFade1 += 20;
                          }
                      } else {
                          if (lightFade1 <= 0) {
                              lighton1 = true;
                          } else {
                              lightFade1 -= 20;
                          }
                      }
                      
                      rectMode(CORNER);
                      
                      stroke(70);
                      strokeWeight(3);
                      line(80, 140, 80, 177);
                      line(80.5, 140, 90, 126);
                      line(90, 106, 90, 125);
                      line(80.5, 90, 90, 105);
                      line(80, 90, 80, 61);
                      noStroke();
                      
                      ninja(950, 450, 0.4, 25);
                      
                      badguy(153, 893, 0.17);
                      badguy(590, 1015, 0.14);
                      badguy(336, 939, 0.2);
                      
                      boxes(105, 440, 5);
                      boxes(213, 452, 4);
                      boxes(105, 344, 3);
                      
                      boxes(422, 393, 5);
                      boxes(379, 451, 4);
                      boxes(485, 537, 3);
                      
                      boxes(214, 176, 3);
                      boxes(321, 216, 2);
                      boxes(212, 265, 1.5);
                      
                      securityCamera1(911, 432, 153, 1.5);
                      
                  };
                  pushMatrix()
                  graphic();
                  popMatrix();
                  return get(0, 0, width, height);
                },
                diamond() {
                  ctx.clearRect(0, 0, width, height);
                  pushMatrix();
                  ctx.beginPath()
                  scale(width / 105);
                  translate(-147, -175); 
                  rectMode(CENTER);
                  stroke(226, 230, 0);
                  strokeWeight(3);
                  line(185,200,185,185);
                  line(215,200,215,185);
                  noStroke();
                  fill(201, 201, 201);
                  rect(200,235,50,70);
                  quad(175,270,225,270,230,280,170,280);
                  fill(117, 117, 117);
                  rect(185,230,6,50,10);
                  rect(200,230,6,50,10);
                  rect(215,230,6,50,10);
                  fill(0, 255, 255);
                  triangle(200,200,220,180,180,180);
                  quad(220,180,180,180,185,175,215,175);
                  stroke(0, 0, 0);
                  strokeWeight(0.3);
                  line(200,200,200,175);
                  line(200,200,210,181);
                  line(210,181,208,175);
                  line(190,181,192,175);
                  line(200,200,190,181);
                  line(180,180,220,180);
                  line(175,270,225,270);
                  popMatrix();
                  return get(0, 0, width, height);
                },
                ninja() {
                  ctx.clearRect(0, 0, width, height)
                  rectMode(CORNER)
                  ctx.save();
                  
                  //main shape
                  {
                      noStroke();
                      fill(0, 0, 0);
                      rect(107,103,200,200);
                  }
                  
                  //face
                  {
                      fill(255, 235, 181);
                      rect(147,153,160,50);
                      
                      //eyes
                      {
                          fill(0, 0, 0);
                          ellipse(203,173,20,23);
                          ellipse(267,173,20,23);
                      }
                      
                  }
                  
                  //headband
                  {
                      fill(168, 0, 0);
                      beginShape();
                      vertex(99, 133);
                      bezierVertex(123, 152, 248, 139, 311, 137);
                      bezierVertex(315, 132, 304, 133, 311, 124);
                      bezierVertex(229, 120, 153, 130, 103, 128);
                      endShape();
                      
                      fill(128, 10, 10);
                      beginShape();
                      vertex(106, 133);
                      bezierVertex(105, 150, 80, 160, 62, 156);
                      bezierVertex(80, 142, 95, 134, 103, 128);
                      endShape();
                      
                      fill(168, 0, 0);
                      beginShape();
                      vertex(106, 133);
                      bezierVertex(114, 161, 105, 160, 79, 171);
                      bezierVertex(93, 152, 95, 134, 103, 128);
                      endShape();
                  }
                  
                  //belt
                  {
                      fill(196, 196, 196);
                      rect(110, 240, 10, 41);
                      rect(125, 240, 10, 41);
                      rect(140, 240, 10, 41);
                      
                      fill(64, 64, 64);
                      rect(107,251,200,20);
                  }
                  ctx.restore();
                  return get(62, 59, 288, 288);
              },
            },
            loaded: false,
            loadIndex: 0,
            load() {
                const imgKeys = Object.keys(this.imgs)
                if(this.loadIndex >= imgKeys.length) {
                    return this.loaded = true
                }
                const key = imgKeys[this.loadIndex]
                this.imgs[key] = this.imgs[key]()
                this.loadIndex++
            },
            display(name, x, y, w, h) {
                if(!this.loaded) {
                    return console.error("Can't display images before loading")
                }
                if(!this.imgs[name]) {
                    return console.error("Unknown image")
                }
                image(this.imgs[name], x, y, w, h)
            }
        }

        /** SCENE HANDLING */
        const scene = {
          page: null,
          pages: {},
          use(name, cb) {
            this.pages[name] = cb
          },
          transitionTimer: 0,
          transitionStarted: false,
          transitionTime: 10,
          nextPage: null,
          to(page, transition = true) {
            if(transition) {
              this.nextPage = page
              this.transitionStarted = true
              this.transitionTimer = 0
            }else {
              this.page = page
            }
          },
          run() {
            if(!this.pages[this.page]) {
              background(255)
              fill(0)
              textSize(30)
              textAlign(CENTER, CENTER)
              text("Page not found", width / 2, height / 2)
            }
            this.pages[this.page]?.()
            if(this.transitionStarted || this.transitionTimer > 0) {
              const amt = 1 / this.transitionTime
              this.transitionTimer += this.transitionStarted ? amt : -amt
            }
            if(this.transitionStarted) {
              fill(0, this.transitionTimer * 255)
              rect(0, 0, width, height)
              if(this.transitionTimer >= 1) {
                this.transitionStarted = false
                this.page = this.nextPage
              }
            }
          }
        }

        /** ICONS */
        const icons = {
          home(x, y, s) {
            ctx.save()
            translate(x, y)
            scale(s / 50)
            triangle(-25, -10, 0, -25, 25, -10)
            rect(-17, -11, 34, 30)
            ctx.restore()
          } 
        }

        /** Button class */
        class Button {
          constructor(config) {
            this.x = config.x
            this.y = config.y
            this.w = config.w
            this.h = config.h
            this.onClick = config.onClick
            this.text = config.text
            this.icon = config.icon
            this.underMouse = false
            this.pressed = false
            this.dragover = false
          }
          run() {
            if(!mouseIsPressed && this.pressed) {
              this.onClick()
            }
            this.underMouse = mouseX > this.x && mouseX < this.x + this.w && mouseY > this.y && mouseY < this.y + this.h
            this.pressed = this.underMouse && mouseIsPressed
            const shBlur = this.underMouse ? 20 : 10
            ctx.save()
            ctx.beginPath()
            ctx.shadowBlur = shBlur
            ctx.shadowColor = "#f00"
            fill(0)
            stroke(255)
            strokeWeight(5)
            rect(this.x, this.y, this.w, this.h)

            ctx.shadowBlur = 0

            if(this.text) {
              textAlign(CENTER, CENTER)
              textSize(25)
              ctx.lineWidth = 2
              stroke(255, 0, 0)
              ctx.strokeText(this.text, this.x + this.w / 2, this.y + this.h / 2)
            }
            else if(this.icon) {
              fill(255, 0, 0)
              noStroke()
              this.icon(this.x + this.w / 2, this.y + this.h / 2, 23)
            }
            ctx.restore()
          }
        }

        /** Faith's sprites */
        var ninja = function(x,y,s){
          pushMatrix();
          scale(s / 200);
          translate(x,y);
          translate(-107, -103);
          
          noStroke();
          fill(0, 0, 0);

          rect(107,103,200,200);

          fill(217, 130, 76);
          rect(153,153,154,50);

          fill(168, 0, 0);
          rect(107,133,200,20);

          fill(64, 64, 64);
          rect(107,251,200,20);

          stroke(168, 0, 0);
          strokeWeight(10);
          line(86,175,111,140);
          line(66,160,111,138);

          fill(0, 0, 0);
          noStroke();
          ellipse(218,173,20,17);
          ellipse(282,173,20,17);

          stroke(0, 0, 0);
          strokeWeight(3);
          line(236,169,197,159);
          line(297,168,268,163);

          popMatrix();

        };
        var badguy = function(x,y,s){
          pushMatrix();
          scale(s / 200);
          translate(x,y);
          
          noStroke();
          fill(64, 64, 64);
          
          rect(107,103,200,200);
          
          fill(161, 157, 155);
          rect(107,153,200,50);
          
          fill(64, 64, 64);
          rect(87,133,240,20);
          
          fill(64, 64, 64);
          rect(107,251,200,20);
          
          fill(0, 0, 0);
          noStroke();
          ellipse(170,176,40,40);
          ellipse(260,176,40,40);
          
          stroke(0, 0, 0);
          strokeWeight(3);
          line(108,176,305,176);
          
          fill(0, 0, 0);
          rect(257,247,27,35);
          rect(277,239,7,35);
          
          fill(36, 36, 36);
          noStroke();
          rect(108,254,199,19);
          
          popMatrix();
      }
        

        /** Ace Roger's camera graphic */
        var securityCameras = function (x, y, s) {
          pushMatrix();
              translate(x, y);
              scale(s);
              
              // Lights {
              
              stroke(0);
              strokeWeight(3);
              line(-275, -279, -275, -254);
              
              noStroke();
              fill(80);
              arc(-275, -283, 15, 10, 0, 180);
              arc(-275, -282.7, 15, 4, -180, 0);
              
              pushMatrix();
                  translate(-274, -247);
                  rotate(r);
                  
                  noStroke();
                  
                  fill(50);
                  rectMode(CENTER);
                  rect(0, 0, 30, 20, 3);
                  
                  rect(9, 0, 30, 10, 2);
                  
                  fill(80);
                  ellipse(-13.6, 0, 3, 20);
                  
                  fill(255, 100, 100, 150);
                  ellipse(-3, 6, 3, 3);
                  
                  fill(255, 0, 0, lightFade);
                  ellipse(-3, 6, 6, 6);
                  
                  fill(255, 255, 0, 60);
                  arc(399, 0, 750, 100, 91, 270);
                  arc(399, 0, 50, 100, -89, 90);
                  
                  fill(70);
                  rect(-3, -4, 10, 8);
                  
                  fill(255, 100);
                  ellipse(23, 0, 2, 10);
                  
                  noFill();
                  stroke(255, 0, 0);
                  strokeWeight(1);
                  beginShape();
                  curveVertex(38,  15);
                  curveVertex(2,  -2);
                  curveVertex(-8, -6);
                  curveVertex(-17, -46);
                  endShape();
                  
                  noFill();
                  stroke(0, 200, 0);
                  beginShape();
                  curveVertex(65,  0);
                  curveVertex(2,  -5);
                  curveVertex(-7, -2);
                  curveVertex(-73, -5);
                  endShape();
                  
                  noStroke();
                  
                  pushMatrix();
                      translate(-6, -6);
                      rotate(66);
                      
                      fill(130);
                      rect(-3, -4, 10, 8);
                      
                      for (var i = -6; i <= 0; i += 2) {
                          stroke(100);
                          strokeWeight(1);
                          line(i, -2, i, -6);
                      }
                      
                  popMatrix();
                  
                  noStroke();
                  
              popMatrix();
              
              // }
              
              if (rup) {
                  if (r >= 170) {
                      rup = false;
                  } else {
                      r += 0.1;
                  }
              } else {
                  if (r <= 40) {
                      rup = true;
                  } else {
                      r -= 0.1;
                  }
              }
              
              if (lighton) {
                  if (lightFade >= 100) {
                      lighton = false;
                  } else {
                      lightFade += 3;
                  }
              } else {
                  if (lightFade <= 0) {
                      lighton = true;
                  } else {
                      lightFade -= 3;
                  }
              }
              
          popMatrix();
      };
        
        
        /** Particle class */
        class Particle {
          constructor(x, y, col, life, velX = 0, velY = 0) {
            this.x = x
            this.y = y
            this.color = col
            this.life = life
            this.maxLife = life
            this.velX = velX
            this.velY = velY
            this.damping = 0.95
            this.dead = false
          }
          update() {
            if(this.dead) return
            this.life--
            this.velX *= this.damping
            this.velY *= this.damping
            this.x += this.velX
            this.y += this.velY
            if(this.life <= 0) this.dead = true
          }
          display() {
            fill(...this.color, this.life / this.maxLife * 255)
            noStroke()
            rect(this.x - 4, this.y - 4, 8, 8)
          }
        }
        let particles = []
      
      
        /** Camera that tracks player */
        const cam = {
          x: 0, 
          y: 0,
          w: width,
          h: height,
          centerX: 0.5,
          centerY: 0.5,
          speed: 0.3,
          bounds: {},
          follow(x, y) {
            let targetX = (x - width * this.centerX)
            let targetY = (y - height * this.centerY)
            
            if(this.bounds.minX != undefined) {
              targetX = Math.max(targetX, this.bounds.minX)
            }
            if(this.bounds.maxX != undefined) {
              targetX = Math.min(targetX, this.bounds.maxX - width)
            }
            if(this.bounds.minY != undefined) {
              targetY = Math.max(targetY, this.bounds.minY)
            }
            if(this.bounds.maxY != undefined) {
              targetY = Math.min(targetY, this.bounds.maxY - height)
            }
            this.x += (targetX - this.x) * this.speed
            this.y += (targetY - this.y) * this.speed
          },
          setBounds(bounds) {
            this.bounds = bounds
          },
          run() {
            translate(Math.round(-this.x), Math.round(-this.y))
          },
          inWindow(entity) {
            return rectRectCollide(entity, this)
          }
        }
        
        /** Raycasting stuff */
        //{
        const sign = (n) => n < 0 ? -1 : n > 0 ? 1 : 0
        /** returns the intersection point of two lines, if any */
        function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
          const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
          if(!denom) return
        
          const tNum = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)
          const uNum = (x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)
        
          const t = tNum / denom
          const u = uNum / denom
          if(t > 0 && t < 1 && u > 0 && u < 1) {
            let endX = x1 + t * (x2 - x1), endY =  y1 + t * (y2 - y1)
            return { x: endX, y: endY }
          }
          return false
        }
        
        /** Gets the closest game object (crate, player, etc) */
        const getClosestGameObjectIntersection = (x, y, angle, maxDistance) => {
          const endX = x + Math.cos(angle) * maxDistance
          const endY = y + Math.sin(angle) * maxDistance
          let closestIntersection, closestDist;
          let thisLine = [x, y, endX, endY]
          for(const o of physicsObjects) {
            if(!o.edges) continue;
            // console.log(o.edges)
            const intersections = o.edges.map(function(edge) {
              return lineIntersect(...thisLine, ...edge)
            })
            // console.log(intersections)
            for(const i of intersections) {
              if(!i) continue
              const distTo = dist(x, y, i.x, i.y)
              if(!closestIntersection || distTo < closestDist) {
                closestDist = distTo
                closestIntersection = i
              }
            }
          }
          return closestIntersection || { x: endX, y: endY }
        }
        
        /** Gets the closest tile */
        function isSolidTile(data) {
          return data && data !== '|'
        }
        const getClosestTileIntersection = (x, y, angle, maxDistance) => {
          x /= BLOCK_SIZE
          y /= BLOCK_SIZE
          maxDistance /= BLOCK_SIZE
          const dirX = Math.cos(angle)
          const dirY = Math.sin(angle)
          const moveX = Math.sqrt(1 + (dirY / dirX) ** 2)
          const moveY = Math.sqrt(1 + (dirX / dirY) ** 2)
        
          let tileX = ~~x
          let tileY = ~~y
        
          let stepX, stepY
          let rayX, rayY;
        
          if(dirX < 0) {
            stepX = -1
            rayX = (x - tileX) * moveX
          }else {
            stepX = 1
            rayX = (tileX + 1 - x) * moveX
          }
          if(dirY < 0) {
            stepY = -1
            rayY = (y - tileY) * moveY
          }else {
            stepY = 1
            rayY = (tileY + 1 - y) * moveY
          }
        
          let bTileFound = false
          let currentDistance = 0;
          while(!bTileFound && currentDistance < maxDistance) {
            if(rayX < rayY) {
              tileX += stepX
              currentDistance = rayX
              rayX += moveX
            }else {
              tileY += stepY
              currentDistance = rayY
              rayY += moveY
            }
            if(tileX >= 0 && tileX < tileMapSize.w && tileY >= 0 && tileY < tileMapSize.h) {
              if(isSolidTile(tileData[tileX + tileY * tileMapSize.w])) {
                bTileFound = true
                // if(stepY > 0) break;
              }
            }
          }
          if(bTileFound) {
            return { 
              x: (x + dirX * currentDistance) * BLOCK_SIZE,
              y: (y + dirY * currentDistance) * BLOCK_SIZE
            }
          }
          return {
            x: (x + dirX * maxDistance) * BLOCK_SIZE,
            y: (y + dirY * maxDistance) * BLOCK_SIZE,
          }
        }
        
        /** Casts a ray, if it hits an object, it returns that point */
        const castRay = (x, y, angle, maxDistance) => {
          let ot = getClosestGameObjectIntersection(x, y, angle, maxDistance)
          let tt = getClosestTileIntersection(x, y, angle, maxDistance)
          return dist(x, y, ot.x, ot.y) < dist(x, y, tt.x, tt.y) ? ot : tt
        }
        const roundTo = (n, a) => Math.round(n / a) * a
        
        function renderRaycast(x, y, angle, fov, distance, c) {
          fill(c)
          stroke(c)
          beginShape()
          vertex(x, y)
          const stepSize = Math.PI / 100
          const stop = Math.ceil(fov / stepSize)
          // console.log(stop)
          for(var i = 0; i <= stop; i++) {
            let a = angle + (i / stop) * fov - fov / 2
            if(i && i < stop) {
                a = roundTo(a, stepSize)
            }
            const pos = castRay(x, y, a, distance)
            vertex(pos.x, pos.y)
          }  
          endShape(CLOSE)
        } 
        
        //}
        
        /** game objects */
        //{
        /** Checks if two rectangles overlap */
        function rectRectCollide(a, b) {
          return a.x > b.x - a.w && a.x < b.x + b.w && a.y > b.y - a.h && a.y < b.y + b.h
        }
        /** basically same thing as above */
        function rectRectNoVecCollide(x1, y1, w1, h1, x2, y2, w2, h2) {
          return x1 > x2 - w1 && x1 < x2 + w2 && y1 > y2 - h1 && y1 < y2 + h2
        }
        
        /** Keeps track of all objects in world */
        let physicsObjects = []
        
        /** Physics object class */
        class PhysicsObject {
          constructor(x, y, w, h) {
            this.x = x
            this.y = y
            this.w = w
            this.h = h
            this.center = { x: this.x + this.w / 2, y: this.y + this.h / 2 }
            this.velX = 0
            this.velY = 0
            this.damping = 0.99
            this.gravityScale = 1
            this.elasticity = 0
            this.mass = 1
            this.friction = 0.1
            physicsObjects.push(this)
          }
          update() {
            if(!this.mass) return
            const oldX = this.x, oldY = this.y
        
            this.center = { x: this.x + this.w / 2, y: this.y + this.h / 2 }
        
            this.velX *= this.damping
            this.x += this.velX
            this.velY = this.velY * this.damping + GRAVITY * this.gravityScale
            this.y += this.velY
        
            const movingDown = this.velY > 0
        
            if(this.groundObject) {
              this.velX *= (1 - this.friction)
              this.groundObject = null
            }
            
            this.left = false
            this.right = false

            for(var i = 0; i < physicsObjects.length; i++) {
              const o = physicsObjects[i]
              if(o == this || !rectRectCollide(this, o)) continue;
              if(!this.collideWithObject(o) || !o.collideWithObject(this)) continue
              const smallStepUp = o.y - oldY > this.h - GRAVITY
              const isBlockedX = oldY + this.h > o.y && oldY < o.y + o.h
              const isBlockedY = oldX + this.w > o.x && oldX < o.x + o.w
              if(smallStepUp || isBlockedY || !isBlockedX) {
                this.y = oldY < o.y ? o.y - this.h : o.y + o.h
                if(!o.mass || (o.groundObject && movingDown)) {
                  if(movingDown) {
                    this.groundObject = o
                  }
                  this.velY *= -this.elasticity
                }else if(o.mass) {
                  this.velY = o.velY = (this.velY * this.mass + o.velY * o.mass) / (this.mass + o.mass)
                }
              }
              if(!smallStepUp && (isBlockedX || !isBlockedY)) {
                this.x = oldX < o.x ? o.x - this.w : o.x + o.w
                this.left = oldX < o.x
                this.right = !this.left
                if(!o.mass) {
                  this.velX *= this.elasticity
                }else {
                  this.velX = o.velX = (this.velX * this.mass + o.velX * o.mass) / (this.mass + o.mass)
                }
              }
            }
            const overlap = checkTileCollision(this.x, this.y, this.w, this.h)
            if(overlap) {
              if(!checkTileCollision(oldX, oldY, this.w, this.h)) {
                const isBlockedX = checkTileCollision(this.x, oldY, this.w, this.h)
                const isBlockedY = checkTileCollision(oldX, this.y, this.w, this.h)
                if(isBlockedX || !isBlockedY) {
                  this.x = oldX
                  this.left = this.velX < 0
                  this.right = !this.left
                  this.velX *= this.elasticity
                }
                if(isBlockedY || !isBlockedX) {
                  this.y = oldY
                  this.velY *= this.elasticity
                  this.groundObject = movingDown
                }
              }
            }
          }
          collideWithObject(o) {
            return 1
          }
        }
        
        /** Player class  */
        class Player extends PhysicsObject {
          constructor(x, y, w, h) {
            super(x, y, w, h)
            this.jumpHeight = 12
            this.maxSpeed = 12
            this.xAccel = 0.5
            this.friction = 0
            this.character = true
            this.dir = 1
            this.landed = false
            this.keyUp = false
            this.found = false
            this.deathImg = null
          }
          update() {
            
            if(this.groundObject && keyIsDown(38)) {
              this.velY = -this.jumpHeight
            }
            // console.log('r ' + this.right, 'l ' + this.left)
            if(keyIsDown(37)) {
              this.velX = Math.max(this.velX - this.xAccel, -this.maxSpeed)
              this.dir = -1
              if(this.left && !this.groundObject) {
                this.velY = min(this.velY, 0)
                if(keyIsDown(38) && !this.keyUp) {
                  this.velY = -this.jumpHeight
                  this.velX = this.jumpHeight
                }
                for(var i = 0; i < 3; i++) {
                  particles.push(new Particle(this.x, this.y + random(0, this.h), [255], 50, random(0, 1), random(-1, 0)))
                }
              }
            }else if(keyIsDown(39)) {
              this.dir = 1
              this.velX = Math.min(this.velX + this.xAccel, this.maxSpeed)
              if(this.right && !this.groundObject) {
                this.velY = min(this.velY, 0)
                if(keyIsDown(38) && !this.keyUp) {
                  this.velY = -this.jumpHeight
                  this.velX = -this.jumpHeight
                }
                for(var i = 0; i < 3; i++) {
                  particles.push(new Particle(this.x + this.w, this.y + random(0, this.h), [255], 50, random(-1, 0), random(-1, 0)))
                }
              }
            }else {
              this.velX *= 0.9
            }
            this.keyUp = keyIsDown(38)

            if(this.groundObject && !this.landed) {
              for(var i = 0; i < 10; i++) {
                particles.push(new Particle(this.x + random(0, this.w), this.y + this.h, [255], 50, random(-1, 1), random(-1, 0)))
              }
            }
            this.landed = !!this.groundObject
            super.update()
          }
          display() {
            pushMatrix()
            translate(this.x, this.y)
            if(this.dir === -1) {
              translate(this.w, 0)
            }
            scale(this.dir, 1)
            scale(this.w / 200)
            translate(-44, -44)
            // const sc = 288 / 200
            img.display('ninja', 0, 0)
            popMatrix()
          }
          collideWithObject(o) {
            return !o.guard
          }
        }

        /** Guard Class */
        class Guard extends PhysicsObject {
          constructor(x, y, w, h) {
            super(x, y, w, h)
            this.seeDistance = 400
            this.jumpHeight = 12
            this.accel = 0.1
            this.maxSpeed = 4
            this.guard = true
            this.friction = 0
            this.awake = false
          }
          canSee(entity) {
            if(!entity) return
            const distToEntity = dist(this.center.x, this.center.y, entity.center.x, entity.center.y)
            if(distToEntity > this.seeDistance) return
            return this.castHits(this.x + 1, this.y + 1, entity.x, entity.y) ||
                this.castHits(this.x + this.w - 1, this.y + 1, entity.x + entity.w, entity.y) ||
                this.castHits(this.x + 1, this.y + this.h - 1, entity.x, entity.y + entity.h) ||
                this.castHits(this.x + this.w - 1, this.y + this.h - 1, entity.x + entity.w, entity.y + entity.h)
          }
          castHits(x, y, ox, oy) {
            const ray = castRay(x, y, Math.atan2(oy - y, ox - x), this.seeDistance)
            return dist(x, y, ray.x, ray.y) > dist(x, y, ox, oy)  
          }
          chase(entity) {
            if(!this.canSee(entity)) {
              if(this.awake) {
                this.awakeTimer++
                this.awake = this.awakeTimer < 100
              }
              if(!this.awake) {
                this.velX *= 0.95
                this.target = false
                this.awake = false
                return
              }
            }else {
              this.awake = true
              this.awakeTimer = 0
            }
            
            this.target = true
            if(this.groundObject) {
              if((entity.y + entity.h < this.y && !entity.groundObject) || this.right || this.left) {
                // this.velY = -this.jumpHeight
              }
              if(this.right || this.left) {
                this.velY = -this.jumpHeight
              }
            }
            // this.accel 
            this.velX = constrain(this.velX + sign(entity.center.x - this.center.x) * this.accel, -this.maxSpeed, this.maxSpeed)
          }
          display() {
            pushMatrix()
            translate(this.x - this.w / 2, this.y - this.h / 2)
            scale(max(sign(this.velX), 1), 1)
            badguy(0, 0, this.w)
            popMatrix()
          }
          update() {
            this.chase(player)
            if(rectRectCollide(this, player)) {
              player.found = true
            }
            super.update()
          }
          collideWithObject(o) {
            return !o.character
          } 
        }

        /** Creates edges for a box for raycasting */
        class RaycastObject extends PhysicsObject {
          update() {
            this.edges = [
              [this.x, this.y, this.x + this.w, this.y],
              [this.x, this.y, this.x, this.y + this.h],
              [this.x + this.w, this.y, this.x + this.w, this.y + this.h],
              [this.x, this.y + this.h, this.x + this.w, this.y + this.h]
            ]
            super.update()
          }
        }
        
        /** Crate class */
        class Crate extends RaycastObject {
          display() {
            img.display('box', this.x, this.y, this.w, this.h)
          }
        }
        
        class Portal extends PhysicsObject {
          update() {
            if(rectRectCollide(this, player)) {
              player.won = true
            }
            if(frameCount % 10 === 0) {
              particles.push(new Particle(this.center.x + random(-5, 5), this.y + 10 + random(-5, 5), [0, 255, 255], 50, random(-1, 1), random(-3, 0)))
            }
            super.update()
          }
          display() {
            img.display('diamond', this.x, this.y, this.w, this.h)
          }
          collideWithObject(o) {
            return !o.character
          }
        }

        class LevelMessage {
          constructor(msg, x, y) {
            this.msg = msg
            this.x = x
            this.y = y
          }
          run() {
            ctx.save()
            fill(255)
            noStroke()
            ctx.shadowBlur = 5
            ctx.shadowColor = '#f00'
            textAlign(CENTER, CENTER)
            textSize(30)
            text(this.msg, this.x, this.y)
            ctx.restore()
          }
        }
        let levelMessages = []
        
        class EnemyCamera {
          constructor(x, y, angle, sequence) {
            this.x = x
            this.y = y
            this.angle = angle
            this.fov = Math.PI / 4
            this.maxDistance = 400
            this.sequence = sequence
            this.time = 0
            this.sequenceLen = this.sequence.reduce((time, c) => time + c[1], 0)
            this.sequenceIndex = 0
            this.sequenceTime = 0
            this.viewBox = { x: this.x - 400, y: this.y - 400, w: 800, h: 800}
          }
          runSequence(t) {
            if(this.sequenceTime >= this.sequence[this.sequenceIndex][1]) {
              this.sequenceTime = 0
              this.sequenceIndex = (this.sequenceIndex + 1) % this.sequence.length
            }
            let current = this.sequence[this.sequenceIndex]
            if(current[0] === 'rotate') {
              this.angle += current[2] / current[1]
            }
            this.time = (this.time + 1) % this.sequenceLen
            this.sequenceTime++
          }
          canSee(entity) {
            // return Math.random() < 0.001
            if(!entity) return
            const angle = Math.atan2(entity.center.y - this.y,entity.center.x - this.x)
            // console.log(angle, normAngle(this.angle))
            const distToEntity = dist(this.x, this.y, entity.center.x, entity.center.y)
            if(distToEntity < this.maxDistance && Math.abs(angle - normAngle(this.angle)) < this.fov / 2) {
              const ray = castRay(this.x, this.y, angle, this.maxDistance)
              if(dist(this.x, this.y, ray.x, ray.y) > distToEntity) {
                return true
              }
            }
          }
          display() {
            if(!cam.inWindow(this.viewBox)) return
            this.runSequence()
            this.seesPlayer = this.canSee(player)
            renderRaycast(this.x, this.y, this.angle, this.fov, this.maxDistance, this.seesPlayer ? color(255, 0, 0, 50) : color(255, 255, 0, 50))
            if(this.seesPlayer) {
              player.found = true
            }
            pushMatrix()
            translate(this.x, this.y)
            stroke(0);
            strokeWeight(3);
            line(0,  - BLOCK_SIZE * 0.5, 0, 0);
            noStroke();
            fill(80);
            arc(0, -BLOCK_SIZE * 0.5, 15, 10, 0, Math.PI / 2);
            rotate(this.angle / Math.PI * 180)
            img.display('fakeCam', -BLOCK_SIZE * 0.5, -BLOCK_SIZE * 0.5, BLOCK_SIZE, BLOCK_SIZE)
            popMatrix()
          }
        }
        let cameras = []
        //}
        
        /** Tile map */
        //{
        let tileData = []
        let tileMapSize = { w: 0, h: 0 }
        
        function initTileData(w, h) {
          tileMapSize = { w, h }
          tileData = new Array(w * h).fill(0)
        }
        
        function putTileData(x, y, data) {
          tileData[x + y * tileMapSize.w] = data
        }

        
        function checkTileCollision(x, y, w, h, velX, velY) {
          const minX = Math.max(0, Math.floor(x / BLOCK_SIZE)),
                minY = Math.max(0, Math.floor(y / BLOCK_SIZE)),
                maxX = Math.min(Math.floor((x + w - 1) / BLOCK_SIZE), tileMapSize.w - 1),
                maxY = Math.min(Math.floor((y + h - 1) / BLOCK_SIZE), tileMapSize.h - 1);
          
          for(let y = minY; y <= maxY; y++) {
            for(let x = minX; x <= maxX; x++) {
              let index = y * tileMapSize.w + x
              if(tileData[index]) {
                return {
                  x: velX < 0 ? x - Math.floor(x / BLOCK_SIZE) * BLOCK_SIZE : x + w - Math.floor((x + w) / BLOCK_SIZE) * BLOCK_SIZE,
                  y: velY < 0 ? y - Math.floor(y / BLOCK_SIZE) * BLOCK_SIZE : y + h - Math.floor((y + h) / BLOCK_SIZE) * BLOCK_SIZE
                }
              }
            }
          }
          return false
        }
        
        function displayTileData() {
          const minX = Math.max(0, Math.floor(cam.x / BLOCK_SIZE)),
                minY = Math.max(0, Math.floor(cam.y / BLOCK_SIZE)),
                maxX = Math.min(Math.floor((cam.x + width) / BLOCK_SIZE), tileMapSize.w - 1),
                maxY = Math.min(Math.floor((cam.y + height) / BLOCK_SIZE), tileMapSize.h - 1);
          for(var ix = minX; ix <= maxX; ix++) {
            for(var jy = minY; jy <= maxY; jy++) {
              const i = ix + jy * tileMapSize.w
              if(!tileData[i]) continue;
              const x = (i % tileMapSize.w) * BLOCK_SIZE
              const y = Math.floor(i / tileMapSize.w) * BLOCK_SIZE
              switch(tileData[i]){
                  case 'm': img.display('metal', x, y, BLOCK_SIZE, BLOCK_SIZE)
                  break
                  case 'r': img.display('rust', x, y, BLOCK_SIZE, BLOCK_SIZE)
                  break
                  case '|':
                    fill(0, 200, 255, 100)
                    noStroke()
                    rect(x, y, BLOCK_SIZE, BLOCK_SIZE)
                  break
              }
            }
          }
        }
        
        function clearData() {
            tileData = []
            physicsObjects = []
            cameras = []
            particles = []
            levelMessages = []
        }
        
        
        //}
        
        /** Run everything */
        //{
        
        /** Player var */
        let player;
        
       
        /** Setting up the scenes */
        let deathTimer = 0
        function goToGame() {
          levelLoaded = false
          currentLevel = null
          scene.to('game')
        }

        const bgMask = cache(BLOCK_SIZE, BLOCK_SIZE, function(c, ctx) {
          ctx.drawImage(img.imgs.metal(), 0, 0, BLOCK_SIZE, BLOCK_SIZE)
          ctx.fillStyle = '#0005'
          ctx.fillRect(0, 0, BLOCK_SIZE, BLOCK_SIZE)
        }, 'pattern')
        
        // buttons for game
        const homeBtn = new Button({
            x: 20, y: 20, w: 30, h: 30, onClick: () => scene.to('menu'), icon: icons.home
        })
        const itFeelsGreatBtn = new Button({
          x: 150, y: 450, w: 300, h: 50, text: "It feels great!", onClick: () => scene.to('win')
        })
        // create game scene
        scene.use('game', () => {
          if(!levelLoaded) loadLevel()
          background(0)

          pushMatrix()
          cam.follow(player.center.x, player.center.y)
          cam.run()
          if(!player.found && !player.reachedPortal && !player.won) {

            ctx.save()
            ctx.fillStyle = bgMask
            ctx.fillRect(cam.x, cam.y, width, height)
            ctx.restore()

            levelMessages.forEach(msg => msg.run())

            cameras.forEach(camera => camera.display())

            displayTileData()

            physicsObjects.forEach(o => {
            //   if(!cam.inWindow(o)) return
              o.update()
              o.display()
            })

            
            // console.log(particles.length)
            for(let i = particles.length - 1; i >= 0; i--) {
              particles[i].update()
              particles[i].display()
              if(particles[i].dead) particles.splice(i, 1)
            }

          }
          popMatrix()

          // special cases

          // something happened to the player
          if((player.found || player.reachedPortal) && !player.img) {
            player.img = get(0, 0, width, height)
          }

          // fell off the map
          if(player.y > tileMapSize.h * BLOCK_SIZE) {
            // reload
            player.dead = true
          }

          // restarting the level
          if(keyIsDown(82)) {
            player.found = false
            player.img = null
            return loadLevel()
          }

          if(player.won) {
            background(0)
            pushMatrix()
            fill(0, 100)
            rect(0, 0, width, height)
            fill(255)
            textAlign(CENTER, CENTER)
            pushMatrix()
            ctx.shadowColor = "#0f0"
            ctx.shadowBlur = 10
            textSize(50)
            text("You found\nthe diamond!", width / 2, height / 2 - 60)
            popMatrix()
            textSize(25)
            text("You have just saved the world!\nHow does it feel?", width / 2, height / 2 + 40)
            popMatrix()
            itFeelsGreatBtn.run()
          }
          else if(player.found) {
            image(player.img, 0, 0)
            pushMatrix()
            // ctx.globalAlpha = constrain((deathTimer - 5) / 10, 0, 1)
            fill(0, 100)
            rect(0, 0, width, height)
            fill(255)
            textAlign(CENTER, CENTER)
            pushMatrix()
            ctx.shadowColor = "#f00"
            ctx.shadowBlur = 10
            textSize(50)
            text("You were caught!", width / 2, height / 2 - 20)
            popMatrix()
            textSize(25)
            text("Press R to restart", width / 2, height / 2 + 20)
            popMatrix()
          }
          else if(player.reachedPortal) { 
            deathTimer++  
            image(player.img, 0, 0)
            if(deathTimer > 50) {
              deathTimer = 0
              player.reachedPortal = false
              player.img = null
              levelIndex++
              completedLevels = max(levelIndex, completedLevels)
              localStorage.setItem("NINJA_VIGIL/completedLevels", completedLevels)
              loadLevel()
            }
          }
          else if(player.dead) {
            deathTimer++
            if(deathTimer > 40) {
              player.dead = false
              deathTimer = 0
              loadLevel()
            }
          }
          
          // player made it to the end of the level
          if(player.x > tileMapSize.w * BLOCK_SIZE) {
            player.reachedPortal = true
          }
          
          homeBtn.run()
        })
        
        // create win scene
        scene.use('win', () => {
          img.display('backgroundImage', 0, 0)
          fill(0, 200)
          rect(0, 0, width, height)
          fill(255, 0, 0)
          textAlign(CENTER, CENTER)
          textSize(20)
          text(getCenteredText("Without the diamond, the power of the elites is broken. You take it back to your superiors. When you come into the headquarters, your boss is sitting casually, a tight-lipped smile on his face. \"Good work, agent,\" he says. Suddenly, two large men grab you. The diamond is wrenched from your hands. \"Thank you very much indeed\" your boss says again, and lets out an evil laugh. \"Take him away\" he orders. You are dragged away, about to suffer the fate you thought you had just prevented.", 300, 300, 450, 0), 300, 300)
          fill(255)
          text("Tell us in the Tips and Thanks\nthat you finished all the levels!", 300, 500)
        })
        
        // buttons for menu
        const playBtn = new Button({
          x: 225, y: 300, w: 150, h: 50, onClick: () => scene.to('game'), text: "Play"
        })
        const howBtn = new Button({
          x: 225, y: 380, w: 150, h: 50, onClick: () => scene.to('how'), text: "How"
        })
        const levelsBtn = new Button({
          x: 225, y: 460, w: 150, h: 50, onClick: () => scene.to('levels'), text: "Levels"
        })
        // create menu scene
        scene.use('menu', () => {
          img.display('backgroundImage', 0, 0, width, height)
          fill(0, 0, 0, 200)
          rect(0, 0, width, height)
          pushMatrix()
          textAlign(CENTER, CENTER)
          stroke(255)
          strokeWeight(3)
          // ctx.fillStyle = titleMask
          ctx.strokeStyle = "#f00"
          ctx.shadowBlur = 5
          ctx.shadowColor = '#f00'
          textSize(80)
          text("Vigil", 300, 100)
          text("Ninja", 300, 200)
          textSize(20)
          text("Of the", 300, 147)
          popMatrix()
          playBtn.run()
          howBtn.run()
          levelsBtn.run()
        })
        
        // buttons for levels scene
        const levelBtns = []
        levels.forEach((level, index) => {
          const x = (index % 5)
          const y = ~~(index / 5)
          levelBtns.push(new Button({
            x: 75 + x * 100, y: 50 + y * 100, w: 50, h: 50, onClick: () => {
              if(completedLevels < index) return
              levelIndex = index
              goToGame()
            }, text: (index + 1).toString()
          }))
        })
        const homeFromLevels = new Button({
            x: 250, y: 500, w: 100, h: 40, text: "Home", onClick: () => scene.to('menu')
        })
        // create levels scene
        scene.use('levels', () => {
          img.display('backgroundImage', 0, 0, width, height)
          fill(0, 0, 0, 200)
          rect(0, 0, width, height)
          levelBtns.forEach((b, i) => {
            b.run()
            if(completedLevels < i) {
              pushMatrix()
              stroke(255, 0, 0)
              strokeWeight(3)
              line(b.x, b.y, b.x + b.w, b.y + b.h)
              popMatrix()
            }
          })
          homeFromLevels.run()
        })

        // buttons for how scene
        const homeFromHowBtn = new Button({
          x: 250, y: 520, w: 100, h: 40, text: "Home", onClick: () => scene.to('menu')
        })
        // create how scene
        scene.use('how', () => {
          img.display('backgroundImage', 0, 0, width, height)
          fill(0, 0, 0, 200)
          rect(0, 0, width, height)
          ctx.save()
          textAlign(CENTER, CENTER)
          textSize(23)
          fill(255)
          ctx.shadowBlur = 5
          ctx.shadowColor = "#f00"
          text(getCenteredText("An evil group of conspirators has created a magic diamond that gives them power over the world. You have been sent on a misson by a small group of rebels to infiltrate the stronghold of the elites and steal their diamond. However, it is heavily guarded. You will have to be careful not to alert security or be captured by one of the guards. Avoid cameras. You can grip the wall by pressing an arrow in the direction of the wall while you are on the wall. Press the up arrow while gripping a wall to wall jump.\nGood luck.", 300, 300, 450, 200), 300, 270)
          ctx.restore()
          homeFromHowBtn.run()
        })
    
        scene.use('load', () => {
            !img.loaded && img.load()
            background(0)
            textAlign(CENTER, CENTER)
            textSize(25)
            fill(255)
            text("Loading...", 300, 300)
            if(img.loaded) {
                if(!scene.transitionStarted) {
                  scene.to('menu')
                }
                return 
            }
        })
        // begin by loading
        scene.to('load', false)

        draw = function() {
          textFont("Sigmar One", 30)
          scene.run()
        }
        
        //}
        </script>
    </body>
</html>
<!-- done... -->
